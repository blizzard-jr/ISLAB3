## Реализация допа 
- Использовал `javax.transaction.xa.Xid` через класс `SimpleXid`.
- Сделал `ApplicationXaManager`: фиксирует фазы `ACTIVE → PREPARED → COMMITTED/ROLLED_BACK` в БД (`ImportOperation.xaXid`, `xaStatus`).
- Интегрировали в импорт: при старте операции генерируется Xid, на prepare отмечаем операцию, на ошибке делаем rollback (удаляем загруженные файлы), на успехе — commit.

## Как поменялась обработка
- **Раньше**: транзакция только БД (@Transactional). MinIO я иммитировал как участника транзакции с сохранением состояния. 
- **Сейчас**: Появился 2PC-оркестратор.
  - Begin: создаётся `ImportOperation` со статусом `PENDING`, генерируется Xid (`xaStatus=ACTIVE`).
  - Prepare: перед обработкой файлов — `xaStatus=PREPARED`.
  - Work: загрузка файлов в MinIO, парсинг YAML, валидация, сохранение сущностей, логирование конфликтов.
  - Commit: при успехе `ImportOperation` помечается `SUCCESS`, `xaStatus=COMMITTED`.
  - Rollback: при любой ошибке все загруженные в текущей операции ключи удаляются из MinIO (если недоступен — статус `REMOVE_REQUIRES` в `ImportFile`), `xaStatus=ROLLED_BACK`, БД-транзакция откатывается.

## Почему не полноценный XA-менеджер
- MinIO не предоставляет XAResource и не поддерживает 2PC протокол нативно.
- Поэтому реализован application-level координационный слой: я сохраняю Xid/фазы в БД и выполняем компенсирующие действия (удаление файлов) вместо настоящего XA-коммита/роллбэка на уровне хранилища.

По сути у меня была похожая логика но без идентификации транзакции, поэтому я обрабатывал файлы в цикле. 

